// Generated by CoffeeScript 1.6.2
(function() {
  var start;

  start = function() {
    var bufferon, clear, currentkey, cycle, cycleTimer, delay_timer, draw, drawTimer, fonts, i, ii, keyTimer, keydown, keypress, keys, memory, opcode, opx, pc, pointer, prevscreen, refresh, rom, running, screen, sound_timer, stack, stdin, t, v, val, x, y, _i, _j, _k, _len, _ref;

    stdin = process.openStdin();
    require('tty').setRawMode(true);
    opcode = 0;
    memory = new Uint8Array(4096);
    v = [];
    for (ii = _i = 0; _i <= 15; ii = ++_i) {
      v[ii] = 0;
    }
    x = 0;
    y = 0;
    i = 233;
    sound_timer = 0;
    delay_timer = 0;
    pc = 0x200;
    stack = [];
    pointer = 0;
    screen = [];
    bufferon = false;
    currentkey = 0;
    running = true;
    keydown = 0;
    keypress = 0;
    keyTimer = null;
    drawTimer = 0;
    cycleTimer = 0;
    prevscreen = [];
    refresh = function() {
      var xx, yy, _j, _k, _results;

      for (yy = _j = 0; _j <= 31; yy = ++_j) {
        prevscreen[yy] = [];
      }
      _results = [];
      for (yy = _k = 0; _k <= 31; yy = ++_k) {
        _results.push((function() {
          var _l, _results1;

          _results1 = [];
          for (xx = _l = 0; _l <= 63; xx = ++_l) {
            _results1.push(prevscreen[yy][xx] = true);
          }
          return _results1;
        })());
      }
      return _results;
    };
    refresh();
    clear = function() {
      var xx, yy, _j, _k, _results;

      for (yy = _j = 0; _j <= 31; yy = ++_j) {
        screen[yy] = [];
      }
      _results = [];
      for (yy = _k = 0; _k <= 31; yy = ++_k) {
        _results.push((function() {
          var _l, _results1;

          _results1 = [];
          for (xx = _l = 0; _l <= 63; xx = ++_l) {
            _results1.push(screen[yy][xx] = false);
          }
          return _results1;
        })());
      }
      return _results;
    };
    clear();
    fonts = [0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xF0, 0x10, 0xF0, 0x80, 0xF0, 0xF0, 0x10, 0xF0, 0x10, 0xF0, 0x90, 0x90, 0xF0, 0x10, 0x10, 0xF0, 0x80, 0xF0, 0x10, 0xF0, 0xF0, 0x80, 0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40, 0x40, 0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0, 0x10, 0xF0, 0xF0, 0x90, 0xF0, 0x90, 0x90, 0xE0, 0x90, 0xE0, 0x90, 0xE0, 0xF0, 0x80, 0x80, 0x80, 0xF0, 0xE0, 0x90, 0x90, 0x90, 0xE0, 0xF0, 0x80, 0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0, 0x80, 0x80];
    keys = {
      "1": function() {
        return 0x1;
      },
      "2": function() {
        return 0x2;
      },
      "3": function() {
        return 0x3;
      },
      "a": function() {
        return 0x4;
      },
      "q": function() {
        return 0x5;
      },
      "d": function() {
        return 0x6;
      },
      "e": function() {
        return 0x7;
      },
      "r": function() {
        return 0x8;
      },
      "4": function() {
        return 0x9;
      },
      "s": function() {
        return 0xA;
      },
      "w": function() {
        return 0xB;
      },
      "f": function() {
        return 0xC;
      },
      "z": function() {
        return 0xD;
      },
      "x": function() {
        return 0xE;
      },
      "c": function() {
        return 0xF;
      },
      "v": function() {
        return 0x10;
      },
      "p": function() {
        process.exit();
        return false;
      },
      "l": function() {
        bufferon = !bufferon;
        return false;
      }
    };
    rom = "6e0565006b066a00a30cdab17a043a4012087b023b1212066c206d1fa310dcd122f660006100a312d0117008a30ed0116040f015f00730001234c60f671e680169ffa30ed671a310dcd16004e0a17cfe6006e0a17c02603f8c02dcd1a30ed67186848794603f8602611f8712471f12ac46006801463f68ff47006901d6713f0112aa471f12aa600580753f0012aa6001f018806061fc8012a30cd07160fe890322f6750122f6456012de124669ff806080c53f0112ca610280153f0112e080153f0112ee80153f0112e86020f018a30e7eff80e080046100d0113e00123012de78ff48fe68ff12ee7801480268016004f01869ff1270a314f533f265f12963376400d3457305f229d34500eee0008000fc00aa0000000000";
    rom = "6e0565006b066a00a30cdab17a043a4012087b023b1212066c206d1fa310dcd122f660006100a312d0117008a30ed0116040f015f00730001234c60f671e680169ffa30ed671a310dcd16004e0a17cfe6006e0a17c02603f8c02dcd1a30ed67186848794603f8602611f8712471f12ac46006801463f68ff47006901d6713f0112aa471f12aa600580753f0012aa6001f018806061fc8012a30cd07160fe890322f6750122f6456012de124669ff806080c53f0112ca610280153f0112e080153f0112ee80153f0112e86020f018a30e7eff80e080046100d0113e00123012de78ff48fe68ff12ee7801480268016004f01869ff1270a314f533f265f12963376400d3457305f229d34500eee0008000fc00aa0000000000";
    rom = "6e0565006b066a00a30cdab17a043a4012087b023b1212066c206d1fa310dcd122f660006100a312d0117008a30ed0116040f015f00730001234c60f671e680169ffa30ed671a310dcd16004e0a17cfe6006e0a17c02603f8c02dcd1a30ed67186848794603f8602611f8712471f12ac46006801463f68ff47006901d6713f0112aa471f12aa600580753f0012aa6001f018806061fc8012a30cd07160fe890322f6750122f6456012de124669ff806080c53f0112ca610280153f0112e080153f0112ee80153f0112e86020f018a30e7eff80e080046100d0113e00123012de78ff48fe68ff12ee7801480268016004f01869ff1270a314f533f265f12963376400d3457305f229d34500eee0008000fc00aa0000000000";
    for (ii = _j = 0, _len = fonts.length; _j < _len; ii = ++_j) {
      val = fonts[ii];
      memory[ii] = fonts[i];
    }
    for (t = _k = 0, _ref = rom.length / 2; 0 <= _ref ? _k <= _ref : _k >= _ref; t = 0 <= _ref ? ++_k : --_k) {
      memory[512 + t] = parseInt(rom.slice(t * 2, t * 2 + 2), 16);
    }
    opx = {
      0x00E0: function() {
        return clear();
      },
      0x00EE: function() {
        return pc = stack[--pointer];
      },
      0x1000: function() {
        return pc = opcode & 0xFFF;
      },
      0x2000: function() {
        stack[pointer] = pc;
        pointer++;
        return pc = opcode & 0x0FFF;
      },
      0x3000: function() {
        if (v[x] === (opcode & 0xFF)) {
          return pc += 2;
        }
      },
      0x4000: function() {
        if (v[x] !== (opcode & 0x00FF)) {
          return pc += 2;
        }
      },
      0x5000: function() {
        if (v[x] === v[y]) {
          return pc += 2;
        }
      },
      0x6000: function() {
        return v[x] = opcode & 0xFF;
      },
      0x7000: function() {
        val = (opcode & 0xFF) + v[x];
        if (val > 255) {
          val -= 256;
        }
        return v[x] = val;
      },
      0x8000: function() {
        return v[x] = v[y];
      },
      0x8001: function() {
        return v[x] = v[x] | v[y];
      },
      0x8002: function() {
        return v[x] = v[x] & v[y];
      },
      0x8003: function() {
        return v[x] = v[x] ^ v[y];
      },
      0x8004: function() {
        v[x] = v[x] + v[y];
        v[15] = +(v[x] > 255);
        if (v[x] > 255) {
          return v[x] = v[x] - 256;
        }
      },
      0x8005: function() {
        v[15] = +(v[x] > v[y]);
        v[x] = v[x] + v[y];
        if (v[x] < 0) {
          return v[x] = v[x] + 256;
        }
      },
      0x8006: function() {
        if (v[x] & 0x1) {
          v[15] = 1;
        }
        return v[x] = v[x] >> 1;
      },
      0x8007: function() {
        v[15] = +(v[y] > v[x]);
        v[x] = v[y] - v[x];
        if (v[x] < 0) {
          return v[x] = v[x] + 256;
        }
      },
      0x800E: function() {
        v[15] = +(v[x] & 0x80);
        v[x] = v[x] << 1;
        if (v[x] > 255) {
          return v[x] = v[x] - 256;
        }
      },
      0x9000: function() {
        if (v[x] !== v[y]) {
          return pc += 2;
        }
      },
      0xA000: function() {
        return i = opcode & 0xFFF;
      },
      0xB000: function() {
        return pc = (opcode & 0xFFF) + v[0];
      },
      0xC000: function() {
        return v[x] = Math.floor(5 * 0xFF) & (opcode & 0xFF);
      },
      0xD000: function() {
        var n, xc, xx, yc, yy, _l, _ref1, _results;

        v[15] = 0;
        n = opcode & 0x000F;
        _results = [];
        for (yy = _l = 0, _ref1 = n - 1; 0 <= _ref1 ? _l <= _ref1 : _l >= _ref1; yy = 0 <= _ref1 ? ++_l : --_l) {
          _results.push((function() {
            var _m, _results1;

            _results1 = [];
            for (xx = _m = 0; _m <= 7; xx = ++_m) {
              xc = v[x] + xx;
              yc = v[y] + yy;
              if ((memory[i + yy] >> (7 - xx)) & 0x1) {
                if (screen[v[y] + yy][v[x] + xx]) {
                  v[15] = 1;
                }
                _results1.push(screen[yc][xc] = screen[yc][xc] ^ 1);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      },
      0xE09E: function() {
        if (v[x] === keydown) {
          return pc += 2;
        }
      },
      0xE0A1: function() {
        if (v[x] !== keydown) {
          return pc += 2;
        }
      },
      0xF007: function() {
        return v[x] = delay_timer;
      },
      0xF00A: function() {
        running = false;
        return keypress = function(key) {
          v[x] = key;
          return running = true;
        };
      },
      0xF015: function() {
        return delay_timer = v[x];
      },
      0xF018: function() {
        return sound_timer = v[x];
      },
      0xF01E: function() {
        return i = i + v[x];
      },
      0xF029: function() {
        return i = v[x] * 5;
      },
      0xF033: function() {
        memory[i] = v[x] / 100;
        memory[i + 1] = (v[x] % 100) / 10;
        return memory[i + 2] = v[x] % 10;
      },
      0xF055: function() {
        var itr, _l, _results;

        _results = [];
        for (itr = _l = 0; 0 <= x ? _l <= x : _l >= x; itr = 0 <= x ? ++_l : --_l) {
          _results.push(memory[i + itr] = v[itr]);
        }
        return _results;
      },
      0xF065: function() {
        var itr, _l, _results;

        _results = [];
        for (itr = _l = 0; 0 <= x ? _l <= x : _l >= x; itr = 0 <= x ? ++_l : --_l) {
          _results.push(v[itr] = memory[i + itr]);
        }
        return _results;
      }
    };
    cycle = function() {
      var method, _l;

      for (i = _l = 0; _l <= 9; i = ++_l) {
        if (running) {
          keypress = function(key) {
            keydown = key;
            clearTimeout(keyTimer);
            return keyTimer = setTimeout(function() {
              return keydown = false;
            }, 100);
          };
          opcode = memory[pc] << 8 | memory[pc + 1];
          x = (opcode & 0x0F00) >> 8;
          y = (opcode & 0x00F0) >> 4;
          if (!method) {
            method = opx[opcode & 0xF0FF];
          }
          if (!method) {
            method = opx[opcode & 0xF00F];
          }
          if (!method) {
            method = opx[opcode & 0xF000];
          }
          if (!method) {
            console.log(opcode.toString(16), pc, v, x, y, memory[pc], memory[pc + 1]);
            throw "invalid opcode";
          }
          console.log(opcode.toString(16), pc, v, x, y, memory[pc], memory[pc + 1], i);
          pc += 2;
          method();
          if (sound_timer > 0) {
            console.log('\0x7');
          }
          if (!(sound_timer < 1)) {
            sound_timer--;
          }
          if (!(delay_timer < 1)) {
            delay_timer--;
          }
        }
      }
      return setTimeout(cycle, 10);
    };
    draw = function() {
      var buffer, k, vv, xx, yy, _l, _len1, _len2, _m, _ref1;

      buffer = "";
      for (yy = _l = 0, _len1 = screen.length; _l < _len1; yy = ++_l) {
        k = screen[yy];
        _ref1 = screen[yy];
        for (xx = _m = 0, _len2 = _ref1.length; _m < _len2; xx = ++_m) {
          vv = _ref1[xx];
          if (screen[yy][xx] !== prevscreen[yy][xx]) {
            buffer += "\x1B[" + (yy + 1) + ";" + (xx + 100) + "H";
            buffer += vv ? '\x1B[42m ' : '\x1B[40m ';
            prevscreen[yy][xx] = screen[yy][xx];
          }
        }
      }
      buffer += "\x1B[40m\x1B[" + 32 + ";" + 3 + "H";
      if (!(drawTimer / 500 % 2)) {
        refresh();
        drawTimer = 0;
      }
      if (bufferon) {
        process.stdout.write(buffer);
      } else {

      }
      return setTimeout(draw, 1);
    };
    cycle();
    process.nextTick(draw);
    process.stdin.setRawMode(true);
    process.stdin.setEncoding('utf8');
    return process.stdin.on('data', function(chunk) {
      var method;

      method = keys[chunk.toString()];
      if (method) {
        keypress(method());
      }
      if (!method) {
        return console.log("no mapping: " + chunk);
      }
    });
  };

  start();

}).call(this);

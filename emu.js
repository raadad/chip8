// Generated by CoffeeScript 1.6.2
(function() {
  var start;

  start = function() {
    var bufferon, clear, cttr, cycle, delay_timer, fonts, i, ii, keypress, keys, memory, opcode, opx, pc, pointer, rom, running, screen, sound, sound_timer, stack, stdin, t, v, val, x, xx, y, yy, _i, _j, _k, _l, _len, _m, _n, _ref;

    stdin = process.openStdin();
    require('tty').setRawMode(true);
    opcode = 0;
    memory = new Uint8Array(4096);
    v = [];
    for (ii = _i = 0; _i <= 15; ii = ++_i) {
      v[ii] = 0;
    }
    x = 0;
    y = 0;
    i = 0;
    sound_timer = 0;
    delay_timer = 0;
    pc = 0x200;
    stack = [];
    pointer = 0;
    screen = [];
    for (yy = _j = 0; _j <= 32; yy = ++_j) {
      screen[yy] = [];
    }
    for (yy = _k = 0; _k <= 32; yy = ++_k) {
      for (xx = _l = 0; _l <= 64; xx = ++_l) {
        screen[yy][xx] = ' ';
      }
    }
    bufferon = false;
    running = true;
    keypress = null;
    clear = function() {
      var _m, _n, _results;

      for (yy = _m = 0; _m <= 32; yy = ++_m) {
        screen[yy] = [];
      }
      _results = [];
      for (yy = _n = 0; _n <= 32; yy = ++_n) {
        _results.push((function() {
          var _o, _results1;

          _results1 = [];
          for (xx = _o = 0; _o <= 64; xx = ++_o) {
            _results1.push(screen[yy][xx] = ' ');
          }
          return _results1;
        })());
      }
      return _results;
    };
    clear();
    fonts = [0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xF0, 0x10, 0xF0, 0x80, 0xF0, 0xF0, 0x10, 0xF0, 0x10, 0xF0, 0x90, 0x90, 0xF0, 0x10, 0x10, 0xF0, 0x80, 0xF0, 0x10, 0xF0, 0xF0, 0x80, 0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40, 0x40, 0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0, 0x10, 0xF0, 0xF0, 0x90, 0xF0, 0x90, 0x90, 0xE0, 0x90, 0xE0, 0x90, 0xE0, 0xF0, 0x80, 0x80, 0x80, 0xF0, 0xE0, 0x90, 0x90, 0x90, 0xE0, 0xF0, 0x80, 0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0, 0x80, 0x80];
    keys = [
      {
        "1": function() {
          return 0x1;
        },
        "2": function() {
          return 0x2;
        },
        "3": function() {
          return 0x3;
        },
        "4": function() {
          return 0x4;
        },
        "q": function() {
          return 0x5;
        },
        "w": function() {
          return 0x6;
        },
        "e": function() {
          return 0x7;
        },
        "r": function() {
          return 0x8;
        },
        "a": function() {
          return 0x9;
        },
        "s": function() {
          return 0xA;
        },
        "d": function() {
          return 0xB;
        },
        "f": function() {
          return 0xC;
        },
        "z": function() {
          return 0xD;
        },
        "x": function() {
          return 0xE;
        },
        "c": function() {
          return 0xF;
        },
        "v": function() {
          return 0x10;
        },
        "q": function() {
          process.exit();
          return false;
        },
        "w": function() {
          bufferon = !bufferon;
          return false;
        }
      }
    ];
    rom = "6e0100e06d016a016b018cd08ce24c00122088d0223e3a4012206a017b063c3f7d013d3f120af00a400589e48ee43e4012026a1c6b0d889000e0223e123ca294f833f2652254dab57a0481202254dab57a0500ee8310833483348314a262f31e00eee0a0a0a0e04040404040e020e080e0e020e020e0a0a0e02020e080e020e0e080e0a0e0e020202020e0a0e0a0e0e0a0e020e0";
    for (i = _m = 0, _len = fonts.length; _m < _len; i = ++_m) {
      val = fonts[i];
      memory[i] = fonts[i];
    }
    for (t = _n = 0, _ref = rom.length / 2; 0 <= _ref ? _n <= _ref : _n >= _ref; t = 0 <= _ref ? ++_n : --_n) {
      memory[512 + t] = parseInt(rom.slice(t * 2, t * 2 + 2), 16);
    }
    opx = {
      0x00E0: function() {
        return clear();
      },
      0x00EE: function() {
        return pc = stack[--pointer];
      },
      0x1000: function() {
        return pc = opcode & 0xFFF;
      },
      0x2000: function() {
        stack[pointer] = pc;
        pointer++;
        return pc = opcode & 0x0FFF;
      },
      0x3000: function() {
        if (v[x] === (opcode & 0xFF)) {
          return pc += 2;
        }
      },
      0x4000: function() {
        if (v[x] !== (opcode & 0x00FF)) {
          return pc += 2;
        }
      },
      0x5000: function() {
        if (v[x] !== v[y]) {
          return pc += 2;
        }
      },
      0x6000: function() {
        return v[x] = opcode & 0xFF;
      },
      0x7000: function() {
        return v[x] = v[x] + (opcode & 0xFF);
      },
      0x8000: function() {
        return v[x] = v[y];
      },
      0x8001: function() {
        return v[x] = v[x] | v[y];
      },
      0x8002: function() {
        return v[x] = v[x] & v[y];
      },
      0x8003: function() {
        return v[x] = v[x] ^ v[y];
      },
      0x8004: function() {
        v[x] = v[x] + v[y];
        v[15] = +(v[x] > 255);
        if (v[x] > 255) {
          return v[x] = v[x] - 256;
        }
      },
      0x8005: function() {
        v[15] = +(v[x] > v[y]);
        v[x] = v[x] + v[y];
        if (v[x] < 0) {
          return v[x] = v[x] + 256;
        }
      },
      0x8006: function() {
        if (v[x] & 0x000F) {
          v[15] = 1;
        }
        return v[x] = v[x] >> 1;
      },
      0x8007: function() {
        v[15] = +(v[x] > v[y]);
        v[x] = v[y] - v[x];
        if (v[x] < 0) {
          return v[x] = v[x] + 256;
        }
      },
      0x800E: function() {
        v[15] = v[x] & 0xF;
        v[x] = v[x] << 1;
        if (v[x] > 255) {
          return v[x] = v[x] - 256;
        }
      },
      0x9000: function() {
        if (v[x] !== v[y]) {
          return pc += 2;
        }
      },
      0xA000: function() {
        return i = opcode & 0xFFF;
      },
      0xB000: function() {
        return pc = (opcode & 0xFFF) + v[0];
      },
      0xC000: function() {
        return v[x] = Math.floor(Math.random() * 0xFF) & (opcode & 0xFF);
      },
      0xD000: function() {
        var n, spr, xpos, ypos, _o, _results;

        v[15] = 0;
        n = opcode & 0x000F;
        _results = [];
        for (yy = _o = 0; 0 <= n ? _o <= n : _o >= n; yy = 0 <= n ? ++_o : --_o) {
          spr = memory[i + yy];
          _results.push((function() {
            var _p, _results1;

            _results1 = [];
            for (xx = _p = 0; _p <= 8; xx = ++_p) {
              if (spr & 0x80) {
                xpos = v[x] + xx;
                ypos = v[y] + yy;
                if (ypos > 32) {
                  ypos = 0;
                }
                if (xpos > 64) {
                  xpos = 0;
                }
                if (xpos < 0) {
                  xpos = 64;
                }
                if (ypos < 32) {
                  ypos = 32;
                }
                _results1.push(screen[ypos][xpos] = "#");
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      },
      0xE09E: function() {
        if (keys[v[x]]) {
          return pc += 2;
        }
      },
      0xE0A1: function() {
        if (!keys[v[x]]) {
          return pc += 2;
        }
      },
      0xF007: function() {
        return v[x] = delay_timer;
      },
      0xF00A: function() {
        return v[x] = running = false;
      },
      0xF015: function() {
        return delay_timer = v[x];
      },
      0xF018: function() {
        return sound_timer = v[x];
      },
      0xF01E: function() {
        return i = i + v[x];
      },
      0xF029: function() {
        return i = v[x] * 5;
      },
      0xF033: function() {
        var itr, number, _o, _results;

        number = v[x];
        _results = [];
        for (itr = _o = 3; _o >= 0; itr = --_o) {
          memory[i + (itr - 1)] = parseInt(number % 10);
          _results.push(number = number / 10);
        }
        return _results;
      },
      0xF055: function() {
        var itr, _o, _results;

        _results = [];
        for (itr = _o = 0; 0 <= x ? _o <= x : _o >= x; itr = 0 <= x ? ++_o : --_o) {
          _results.push(memory[i + itr] = v[itr]);
        }
        return _results;
      },
      0xF065: function() {
        var itr, _o, _results;

        _results = [];
        for (itr = _o = 0; 0 <= x ? _o <= x : _o >= x; itr = 0 <= x ? ++_o : --_o) {
          _results.push(v[itr] = memory[i + itr]);
        }
        return _results;
      }
    };
    cttr = 0;
    cycle = function() {
      var buffer, k, method, vv, _len1, _len2, _o, _p, _ref1;

      opcode = memory[pc] << 8 | memory[pc + 1];
      x = (opcode & 0x0F00) >> 8;
      y = (opcode & 0x00F0) >> 4;
      console.log(opcode.toString(16), pc, v, x, y, memory[pc], memory[pc + 1]);
      if (!method) {
        method = opx[opcode & 0xF0FF];
      }
      if (!method) {
        method = opx[opcode & 0xF00F];
      }
      if (!method) {
        method = opx[opcode & 0xF000];
      }
      if (!method) {
        console.log(opcode.toString(16), pc, v, x, y, memory[pc], memory[pc + 1]);
        throw "invalid opcode";
      }
      pc += 2;
      method();
      cttr++;
      if (cttr < -1314) {
        System.exit();
      }
      keypress = function(key) {
        return console.log("lol");
      };
      if (!(sound_timer < 1)) {
        sound_timer--;
      }
      if (!(delay_timer < 1)) {
        delay_timer--;
      }
      if (sound_timer > 1) {
        3;
      }
      buffer = "";
      for (yy = _o = 0, _len1 = screen.length; _o < _len1; yy = ++_o) {
        k = screen[yy];
        buffer += "\x1B[" + yy + ";" + 0 + "H";
        _ref1 = screen[yy];
        for (xx = _p = 0, _len2 = _ref1.length; _p < _len2; xx = ++_p) {
          vv = _ref1[xx];
          buffer += vv;
        }
      }
      buffer += "\x1B[" + 32 + ";" + 0 + "H";
      if (bufferon) {
        process.stdout.write(buffer);
      } else {

      }
      if (running) {
        return setImmediate(cycle);
      }
    };
    process.nextTick(cycle);
    sound = function() {
      return console.log("beep");
    };
    process.stdin.setRawMode(true);
    process.stdin.setEncoding('utf8');
    return process.stdin.on('data', function(chunk) {
      var method;

      console.log(chunk, keys[chunk]);
      if (chunk === "o") {
        process.exit();
      }
      method = keys[chunk.toString()];
      if (method) {
        method();
      }
      return keypress();
    });
  };

  start();

}).call(this);
